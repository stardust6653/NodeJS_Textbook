# 알아두어야 할 자바스크립트
> NodeJS는 자바스크립트 문법을 따르며 매년 새로운 버젼으로 업데이트되는 자바스크립트에 맞추어 6개월에 한번씩 업데이트가 있음


## ES2015+

### const, let
- const와 let은 블록 스코프를 가지고 있으므로 블록 밖에서는 변수에 접근이 불가능함. (블록이라 함은 중괄호 사이({})를 의미-블록문)
- ES2015 이전에 사용되었던 var는 블록 스코프를 가지고 있지 않아 외부에서도 변수값에 접근할 수 있다는 문제가 있었으며 함수 안에 있는 모든 선언들을 끌어올려 해당 함수 유효 범위의 최상단에 선언하는 호이스팅이 발생함.

### 템플릿 문자열
- 큰따옴표나 작은따옴표로 감싸는 기존 문자열과는 다르게 백틱(`)으로 감싸며 문자열 안에 변수를 넣을 수 있음

### 객체 리터럴
- 객체의 메서드에 함수를 연결할 때 클론(:)과 function을 붙이지 않아도 됨
- 속성명과 변수명이 동일한 경웬느 한 번만 써도 됨
- 객체 리터럴 안에 동적 속성을 선언할 수 있음

### 화살표 함수(Arrow function)
- function 선언 대신 `() => {}` 으로 선언가능해졌으며 변수에 대입 시 나중에 재사용 가능함
- 기존 function과 다른 점은 this 바인드 방식으로, es5 에서의 this는 
  1. 함수 실행 시에는 전역(window)객체를 의미
  2. 메소드 실행 시에는 메소드를 소유하고 있는 객체를 의미
  3. 생성자 실행 시에는 새롭게 만들어진 객체를 의미<br/>

  <br/>  
  위와 같이 정의되었지만

  <br/>

  화살표 함수에서는 화살표 함수가 정의된 곳의 문맥을 그대로 따른다. (Lexical this)
  
  <br/>

  그런 이유로 기본적으로는 화살표 함수를 쓰나 this를 사용해야하는 경우에는 화살표 함수와 함수 선언문(function) 중에서 골라 사용한다.
  
### 구조분해 할당
- 배열이나 객체의 속성을 해체하여 그 값을 개별 변수에 담을 수 있게 함
```JS
  //객체 분해

  const user = {
    name : `soye`,
    age : 100,
  }

  const { name } = user

  console.log(`안녕 내 이름은 ${name}이야`)

  //배열 분해

  const cart = ['banana', 'apple', 'rice']

  const [a, b, c] = cart

  console.log(`오늘 장봐올 건 ${a}랑 ${c}야, ${b}는 내일 사자`)
```

### 클래스
- 객체 지향언어에서 클래스는 객체를 효율적이게 만든다. 자바스크립트에서의 클래스 문법은 다른 언어처럼 클래스 기반으로 동작하는 것이 아니라 프로토 타입에 기반해 동작한다.

### 프로미스
- 비동기 처리에 사용되는 객체
- 실행은 바로 하되 결과는 나중에 받는 객체
- 자바스크립트는 비동기 처리를 위해 콜백 함수를 사용하였으나 콜백 헬(콜백이 계속해서 확장되며 쓰이는 것)이 발생해 가독성이 나쁘고 비동기 처리 중 발생한 에러의 처리가 곤란하며 여러 개의 비동기 처리를 한번에 처리하는데 한계가 있음.
- 이를 해소하기 위한 것이 promise.
- 정해진 기능을 수행하고 나서 정상적으로 기능이 수행되었다면 메시지와 함께 결과값을 전달하며 기능 수행 실패 시 에러 메시지를 출력함
```JS
  // 프로미스 객체 생성

  const condition = true //true면 resolve, false면 reject

  //producer
  const promise = new Promise((resolve, reject)=>{
    if(condition){
      resolve('성공')
    }else{
      reject('실패')
    }
  })

  //다른 코드가 들어갈 수 있음

  //consumer
  promise
    .then((message)=>{
      console.log(message) //성공(resolve)한 경우
    })
    .catch((error)=>{
      console.error(error) //실패(reject)한 경우
    })
    .finally(()=>{ //끝나고 나서 무조건 실행
      console.log('무조건')
    })

    /*
      resolve가 호출되면 then의 message가 출력되며 
      reject 가 호출될 시 error가 출력된다. 
      결과와 상관없이 해당 프로세스가 종료되면 finally가 무조건 실행된다.
    */
```
- state(처리상태) : 프로세스가 오퍼레이션을 수행하고 있는 중인지 완료 후 성공했는 지 실패했는 지 여부
  
  - pending(프로세스 생성 후 오퍼레이션 수행 중인 상태)
  - fulfilled(프로세스가 성공적으로 완료된 상태)
  - rejected(파일을 찾을 수 없거나 서버에 문제가 있는 경우)

### async/await
- then과 catch가 반복되는 promise의 단점을 async/await문법을 통해 한번 더 깔끔하게 줄일 수 있음
- 함수 선언부를 일반 함수 대신 async function으로 교체한 후 promise 앞에 await를 붙인다.
- 해당 함수는 해당 프로미스가 resolve될 때까지 기다린 다음에 다음 로직으로 넘어가게 된다.
- 또한 이렇게 정리된 async/await문 내부를 try/catch문으로 감싸 catch 메소드를 대체할 수 있으며 화살표 함수 역시 사용가능하다.
